program → let declseg in stmts end
declseg → typedecls vardecls funcdecls
typedecls → ϵ
typedecls → typedecl typedecls
typedecl → type id := type ;
type → int
type → float
type → id
type → array [ intlit ] of type
vardecls → ϵ
vardecls → vardecl vardecls
vardecl → var ids : type optinit ;
ids → id ids_tail
ids_tail → ϵ
ids_tail → , ids
optinit → ϵ
optinit → := const
funcdecls → ϵ
funcdecls → funcdecl funcdecls
funcdecl → func id ( params ) optrettype begin stmts end ;
params → ϵ
params → neparams
neparams → param neparams_tail
neparams_tail → ϵ
neparams_tail → , neparams
param → id : type
optrettype → ϵ
optrettype → : type
stmts → fullstmt stmts_tail
stmts_tail → ϵ
stmts_tail → fullstmt stmts_tail
fullstmt → stmt ;
stmt → id stmt_id
stmt → if boolexpr then stmts stmt_if
stmt → while boolexpr do stmts enddo
stmt → for id := numexpr to numexpr do stmts enddo
stmt → break
stmt → return numexpr
stmt_id → optoffset := stmt_store
stmt_id → ( numexprs )
stmt_if → endif
stmt_if → else stmts endif
stmt_store → id stmt_store_tail
stmt_store_tail → optoffset term_tail numexpr_tail
stmt_store_tail → ( numexprs )
optoffset → ϵ
optoffset → [ numexpr ]
numexprs → ϵ
numexprs → neexprs
neexprs → numexpr neexprs_tail
neexprs_tail → ϵ
neexprs_tail → , neexprs
boolexpr → clause boolexpr_tail
boolexpr_tail → ϵ
boolexpr_tail → | boolexpr
clause → pred clause_tail
clause_tail → ϵ
clause_tail → & clause
pred → id optoffset boolop pred_tail
pred → const boolop pred_tail
pred → ( boolexpr )
pred_tail → id optoffset
pred_tail → const
boolop → =
boolop → <>
boolop → <=
boolop → >=
boolop → <
boolop → >
numexpr → term numexpr_tail
numexpr_tail → ϵ
numexpr_tail → linop numexpr
linop → +
linop → -
term → factor term_tail
term_tail → ϵ
term_tail → nonlinop term
nonlinop → *
nonlinop → /
factor → const
factor → id optoffset
factor → ( numexpr )
const → intlit
const → floatlit
