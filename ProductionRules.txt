program → let declseg in stmts end
declseg → typedecls vardecls funcdecls
typedecls → ϵ
typedecls → typedecl typedecls
typedecl → type id := type ;
type → int
type → float
type → id
type → array [ intlit ] of type
vardecls → ϵ
vardecls → vardecl vardecls
vardecl → var ids : type optinit;
ids → id ids-tail
ids-tail → ϵ
ids-tail → , ids
optinit → ϵ
optinit → := const
funcdecls → ϵ
funcdecls → funcdecl funcdecls
funcdecl → func id ( params ) optrettype begin stmts end ;
params → ϵ
params → neparams
neparams → param neparams-tail
neparams-tail → ϵ
neparams-tail → , neparams
param → id : type
optrettype → ϵ
optrettype → : type
stmts → fullstmt stmts-tail
stmts-tail → ϵ
stmts-tail → fullstmt stmts
fullstmt → stmt ;
stmt → lvalue := numexpr
stmt → if boolexpr then stmts
stmt-if → endif
stmt-if → else stmts endif
stmt → while boolexpr do stmts enddo
stmt → for id := numexpr to numexpr do stmts enddo
stmt → optstore id (numexprs)
stmt → break
stmt → return numexpr
lvalue → id optoffset
optoffset → ϵ
optoffset → [ numexpr ]
optstore → ϵ
optstore → lvalue :=
numexprs → ϵ
numexprs → neexprs
neexprs → numexpr neexprs-tail
neexprs-tail → ϵ
neexprs-tail → , neexprs
boolexpr → clause boolexpr-tail
boolexpr-tail → ϵ
boolexpr-tail → | boolexpr
clause → pred clause-tail
clause-tail → ϵ
clause-tail → & clause
pred → numexpr boolop numexpr
pred → ( boolexpr )
boolop → =
boolop → <>
boolop → <=
boolop → >=
boolop → <
boolop → >
numexpr → term numexpr-tail
numexpr-tail → ϵ
numexpr-tail → linop numexpr
linop → +
linop → -
term → factor term-tail
term-tail → ϵ
term-tail → nonlinop term
nonlinop → *
nonlinop → /
factor → const
factor → id optoffset
factor → ( numexpr )
const → intlit
const → floatlit
